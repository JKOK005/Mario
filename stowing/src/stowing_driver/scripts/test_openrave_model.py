"""
Author: Johan Kok Zhi Kang 

Description:
This module serves as the motion planner for the UR5 robot. The environment models the actual
competition from APC 2016. 

The file UR5.dae contains the UR5 robot collada model. The manipulator present is called "arm".
Details can be found on OpenRave main site, universalrobots-ur6-85-5-a Robot. 

Sequence of use:
a) Initialize OP_motion_planning object
b) Call init_planning_setup to initialize robot configuration and collision checking
c) Call optimize to obtain trajectories 
d) Call simulate to display motion

Dependencies:
1) Openrave 0.9
2) TrajOpt
3) or_ompl python bindings
4) ur5_lib.py		- Custom library with UR5 kinematics
5) UR5.dae
6) apc_env.xml
"""


import openravepy as op
import trajoptpy
import json
import time
import IPython
import numpy as np
from ur5_lib import Ur5_motion_planner

class OR_motion_planning:
	def __init__(self, env_file):
		"""
		Constructor to initialize the environment and the UR5 robot in APC 2016 settings
		params: 
			env_file <string>	: 	The environment file you want to load
		"""
		self.env 			= op.Environment()
		self.load_environment_context(env_file)

		self.robot 			= self.env.GetRobots()[0]
		self.mario_arm 		= self.robot.GetManipulator('arm')

		self.ur_kin 		= Ur5_motion_planner()

	def load_environment_context(self, env_file):
		try:
			self.env.StopSimulation()
			self.env.SetViewer('qtcoin')
			self.env.Load(env_file)
		except Exception as e:
			print("Failed to load environment")
		return

	def init_planning_setup(self, init_joint_val, collision_struct):
		# Before planning, initilize robot's current configuration and collision checking options
		try:
			__init_arm_joint(init_joint_val)
			__init_collision_checker(collision_struct)
		except Exception as e:
			print("Failed to initialize planning setup")
			print(e)

	def __init_joint_val(self, init_joint_val):
		with self.env:
			arm_indx 			= self.mario_arm.GetArmIndices()
			self.get_robot().SetActiveDOFs(arm_indx)	
			self.get_robot().SetActiveManipulator(self.mario_arm)	
			self.get_robot().SetActiveDOFValues(init_joint_val)

	def __init_collision_checker(self, collision_struct):
		"""
		params: 
			collision_struct <dict> with <key> : <param> values:
				checker <string> : The name of the Checker used for collision detection. Eg. 'pqp' collision checker
				collision_options <list><op::CollisionOptions> : Various collision options available expressed as a list
		"""
		checker 					= collision_struct['checker']
		collision_options 			= collision_struct['collision_options']
		collisionChecker 			= op.RaveCreateCollisionChecker(self.env, checker)

		j = 0
		for i in collision_options:
			j = j|i

		collisionChecker.SetCollisionOptions(j)
		self.env.SetCollisionChecker(collisionChecker)

	def optimize(self, joint_target, algorithm):
		"""
		Optimization of the robot via initialization of motion through different way points
		We start by perform intermediate way point calculations using the OMPL planner with given algorithm
		Optimization of the trajectory is done through a call to TrajOpt
		Params:
			joint_target <list><list><float>	: A series of joint goals combined to form a list
			algorithm <string>					: OMPL_*** algorithm. If 'RRTConnect', then we are using the 'OML_RRTConnect' algorithm
		"""
		# self.__update_DOF()		# Call to refresh DOF of the robot
		trajectory 					= self.__init_traj(joint_target=joint_target, algorithm=algorithm) # Performs initial OMPL_*** planning
		self.traj 					= []
		trajectory_interp 			= self.__interpolate(trajectory=trajectory, n=10)	# Interpolation between waypoints generated by OMPL for finer resolution

		self.__set_request(manip=manip, joint_goal=trajectory[-1], n_steps=len(trajectory_interp))
		self.request.update({"init_info" : {"type" : "given_traj", "data" : trajectory_interp}})				# Way point initialization after path planning

		jd 							= json.dumps(self.request) 					
		prob 						= trajoptpy.ConstructProblem(jd, self.env) 	
		result 						= trajoptpy.OptimizeProblem(prob) 			

		if self.__check_safe(result.GetTraj()):
			pass
		else:
			raise Exception('No path is safe')
		self.traj 	= result.GetTraj().tolist()
				
		return

	def __init_traj(self, joint_target, algorithm):
		"""
		Creates an initial trajectory plan between start and end goal poses
		"""
		# Issue with the init and goal configuratons -> Planner thinks that the arms are in collision

		algo 					= "OMPL_" + algorithm
		planner 				= op.RaveCreatePlanner(self.env, algo)		# Initializes a planner with algorithm
		simplifier 				= op.RaveCreatePlanner(self.env, 'OMPL_Simplifier')

		params 		 			= planner.PlannerParameters()				# Creates an empty param to be filled 
		params.SetRobotActiveJoints(self.robot)
		params.SetGoalConfig(joint_target[0])

		extraParams 			= ('<_nmaxiterations>{:d}</_nmaxiterations>'.format(10000))

		params.SetExtraParameters(extraParams)

		with self.env:
			with self.get_robot():
				print "Starting intial plan using {:s} algorithm".format(algorithm)
				traj 		= op.RaveCreateTrajectory(self.env, '')
				planner.InitPlan(self.get_robot(), params)
				result 		= planner.PlanPath(traj)
				assert result == op.PlannerStatus.HasSolution

				print 'Calling the OMPL_Simplifier for shortcutting.'
				simplifier.InitPlan(self.get_robot(), op.Planner.PlannerParameters())
				result 		= simplifier.PlanPath(traj)
				assert result == op.PlannerStatus.HasSolution

				trajectory 	= [traj.GetWaypoint(i).tolist() for i in range(traj.GetNumWaypoints())]
				return trajectory

	def __interpolate(self,trajectory, n=10):
		"""
		Takes in a trajectory in joint space, converts it to cartesian space using FK, performs linear interpolation between waypoints
		& maps result back to joint space using IK 
		This is done to provide TrajOpt with more points to perform its optimization
		"""
		lst 							= []
		waypoints 						= self.ur_kin.cartesian_from_joint(trajectory)

		for itr in range(len(waypoints) -1):
			current_arm_pose			= waypoints[itr]
			next_arm_pose				= waypoints[itr +1]

			current_arm_translate		= current_arm_pose[:3]				# Gets X / Y / Z values
			next_arm_translate 			= next_arm_pose[:3]

			start 						= np.array(current_arm_translate)
			end 						= np.array(next_arm_translate)
			lst 						+= [list(start + ii*(end - start)/(n)) for ii in range(n +1)]

		# TODO: Figure out how to change a 3D X / Y / Z orientation into joint space. Read up about TrajOpt to understand how it works
		return self.ur_kin.(lst)

	def __set_request(self, joint_goal, n_steps):
		"""
		Initializes a request dictionary that allows for TrajOpt motion planning
		You can change the collision cost penalties as well as the distance to enforce those penalties
		You can add now constraints and penalties if you want
		Params:
			manip <string>			 : "left_arm" or "right_arm"
			joint_goal <list><float> : The goal (in DOF space) to be reached by the planning arm (manip)
			n_steps <int>			 : Number of planning points for TrajOpt. Must correspond to the number of points generated by OMPL
		"""
		self.plan_arm 	= self.mario_arm 	# Sets the planning arm for visual purpose
		self.goal 		= joint_goal

		self.request = {
		  "basic_info" : {
			"n_steps" : n_steps,
			"manip" : manip, # see below for valid values
			"start_fixed" : True # i.e., DOF values at first timestep are fixed based on current robot state
		  },

		  "costs" : [
		  {
			"type" : "joint_vel", # joint-space velocity cost
			"params": {"coeffs" : [100,100,1]} # a list of length one is automatically expanded to a list of length n_dofs

		  },
		  {
			"type" : "collision",
			"params" : {
			  "coeffs" : [10000], # penalty coefficients. list of length one is automatically expanded to a list of length n_timesteps
			  "dist_pen" : [0.1], # robot-obstacle distance that penalty kicks in. expands to length n_timesteps

			  "continuous" : True
			}
		  },

		  {
			"type" : "collision",
			"params" : {
			  "coeffs" : [10000], # penalty coefficients. list of length one is automatically expanded to a list of length n_timesteps
			  "dist_pen" : [0.1], # robot-obstacle distance that penalty kicks in. expands to length n_timesteps

			  "continuous" : False
			}
		  }    
		  ],

		  "constraints" : [
		  {
			"type" : "joint", # joint-space target
			"params" : {"vals" : joint_goal} # length of vals = # dofs of manip

			},	
		  {
			"type"    : "cart_vel",
			"name"    : "s0_vel",
			"params"  : {
			  "max_displacement"  : 1,
			  "first_step"        : 0,
			  "last_step"         : n_steps -1, #inclusive
			  "link"              : "s0"
			}
		  }, 
		  {
			"type"    : "cart_vel",
			"name"    : "s1_vel",
			"params"  : {
			  "max_displacement"  : 1,
			  "first_step"        : 0,
			  "last_step"         : n_steps -1, #inclusive
			  "link"              : "s1"
			}
		  }
		  ]
		}

		return

	def simulate(self):
		"""
		Call to simulate the movement of the desired manip to joint goal
		"""
		for t in self.traj:
			self.robot.SetDOFValues(t, self.robot.GetManipulator(self.plan_arm).GetArmIndices())
			time.sleep(0.1)

	def __check_safe(self, trajectory):
		"""
		Asserts a safe path by calling the collision checker through every iteration of the resultant trajectory
		Return:
			bool : If the path is safe then return True, else False
		"""
		kin = self.env.GetKinBody('dvrk')
		self.env.GetCollisionChecker().SetCollisionOptions(op.CollisionOptions.Contacts)

		for t in trajectory:			
			self.robot.SetDOFValues(t, self.robot.GetManipulator(self.plan_arm).GetArmIndices())
			flag = self.env.CheckCollision(kin.GetLinks()[3], kin.GetLinks()[6])		# Checks for collisions between 2 cylinder arms of the robot

			if flag == True:
				return False		# That means that collision happened
			time.sleep(0.05)
		return True

	def get_robot(self):	
		return self.robot

	def get_manip(self):
		return self.mario_arm

	def set_manip_DOF(self, DOF):
		"""
		Sets the DOF for a given manipulator. Thereafter, a call to update the global DOF status of the robot will be done
		""" 
		arm_indices				= self.get_manip().GetArmIndices()
		self.get_robot().SetDOFValues(DOF, arm_indices)


if __name__ == "__main__":	
	joint_start1 = [3.14/3, 3.14/4, 2]
	joint_start2 = [-3.14/5, 3.14/4, 0]
	manip 		 = "right_arm"

	planner = Motion_planning('env.xml', "right_arm")
	planner.init_collision_checker('pqp', [op.CollisionOptions.Contacts])

	planner.set_manip(name="right_arm", DOF=joint_start2)

	IK_obj = IK.dVRK_IK_simple()                                # Creates an IK object 	
	endEff = IK_obj.get_endEffector_fromDOF([-3.14/2, 3.14/4, -8])
	joint_target = IK_obj.get_joint_DOF(endEff)     

	planner.optimize(manip, joint_target, algorithm="RRTConnect")
	planner.simulate()

	planner.optimize(manip, [joint_start2], algorithm="RRTConnect")
	planner.simulate()

	IPython.embed()

# if __name__ == "__main__":
# 	env 					= op.Environment() 
# 	env.StopSimulation()
# 	env.Load('ur5.dae')
# 	env.SetViewer('qtcoin') 
# 	robot 					= env.GetRobots()[0]		# Gets the loaded ur5 robot
# 	robot.SetDOFValues([0,0,0,1,1,1])
# 	IPython.embed()
